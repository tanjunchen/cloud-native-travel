# eBPF 多内核版本兼容详解

## 为什么需要考虑 eBPF 程序的内核兼容性？

面临的主要问题：

```
为了获取更好的稳定性和社区支持，内核版本（甚至是 Linux  发行版版本）需要持续跟随上游社区进行升级；

为了采纳新技术，新的产品架构可能一开始就会采纳较新的内核，而使用旧内核的遗留系统还需要很长时间的迭代过程；

为了获得更广的用户，很多商业或开源项目不仅要支持最新的内核版本，还需要兼容各种各样的用户环境，而这些用户所使用的内核版本也是千差万别的。
```

旧版本内核运行 ebpf 程序碰到的问题：

第一，新内核引入的 eBPF 新特性无法在旧内核中运行。

第二，新内核中的数据结构、函数签名以及跟踪点等有可能跟旧版本内核不同。

第三，即便是相同的内核版本，不同的编译选项也可能会导致内核数据结构的不同。

## BCC 是如何兼容多内核版本的？

BCC 和 bpftrace 作为使用最广泛的 eBPF 项目，自然也最容易碰到内核兼容性的问题。

主要方式：

第一，在运行 eBPF 程序的时候使用当前系统安装的内核头文件进行就地编译，这样就可以确保 eBPF 程序中所引用的内核数据结构和函数签名等，跟运行中的内核是完全匹配的。

第二，在 eBPF 程序编译前事先探测内核支持的函数签名和数据结构，进而为 eBPF 程序生成适配当前内核的版本。比如，在块设备 I/O 延迟跟踪程序 biolantecy 中，BCC 借助库函数 BPF.get_kprobe_functions() 来判断内核是不是支持特定的探针函数，进而再根据结果去选择挂载点：

## CO-RE

Linux 内核维护者提供了一个更好的方案，那就是一次编译到处执行（Compile Once Run Everywhere，简称 CO-RE）。

eBPF 的一次编译到处执行（简称 CO-RE）项目借助了 BPF 类型格式（BPF Type Format, 简称 BTF）提供的调试信息，再通过下面的四个步骤，使得 eBPF 程序可以适配不同版本的内核：

第一，在 bpftool 工具中提供了从 BTF 生成头文件的工具，从而摆脱了对内核头文件的依赖。

第二，通过对 BPF 代码中的访问偏移量进行重写，解决了不同内核版本中数据结构偏移量不同的问题。

第三，在 libbpf 中预定义不同内核版本中数据结构的修改，解决了不同内核中数据结构不兼容的问题。

第四，在 libbpf 中提供一系列的内核特性探测库函数，解决了 eBPF 程序在不同内核内版本中需要执行不同行为的问题。比如，你可以用 bpf_core_type_exists() 和bpf_core_field_exists() 分别检查内核数据类型和成员变量是否存在，也可以用类似 extern int LINUX_KERNEL_VERSION __kconfig 的方式查询内核的配置选项。

***Linux 内核社区更推荐所有开发者使用 CO-RE 和 libbpf 来构建 eBPF 程序。***

***需要注意的是，CO-RE 需要比较新的内核版本（大于等于 5.2）并且需要打开 CONFIG_DEBUG_INFO_BTF 配置选项。***

那么，不支持 BTF 的内核怎么办呢？根据开源社区的实践经验，有两种不同的解决办法。

第一种，采用条件编译的方式，根据是否支持 CO-RE，生成两个不同的 eBPF 字节码文件。而到程序运行时，再根据内核是否支持 CO-RE 选择对应的字节码文件加载运行。

第二种，采用 Aqua Security 开源的 btfhub ，为目标机器匹配的内核版本下载独立的 BTF 信息库，最后再通过如下的方法借助 libbpf 进行加载：

```
  struct bpf_object_open_opts openopts = {
    .sz = sizeof(struct bpf_object_open_opts),
         // 从BPF_CUSTOM_BTF环境变量读取BTF文件路径
    .btf_custom_path = getenv("BPF_CUSTOM_BTF"),
  };

  obj = hello_btf_bpf__open_opts(&openopts);
  if (!obj) {
    fprintf(stderr, "failed to open and/or load BPF object\n");
    return 1;
  }
```

## 总结

今天，我带你一起梳理了在开发和运行 eBPF 程序过程中可能会碰到的内核版本兼容性问题，并总结了解决这些问题的实践经验。由于不同版本内核的数据结构、函数签名、内核特性以及内核配置等都有可能不同，针对一个版本开发的 eBPF 程序有可能没法直接运行在其他不同版本的内核上。

为了解决这个问题，BCC 采用了运行时编译的方式，直接从目标机器的内核头文件中获取数据结构，但同时也导致了需要为所有目标机器安装开发工具和内核头文件、编译消耗额外资源、eBPF 程序启动慢以及编译时错误难以排查等额外的问题。

相比于 BCC，CO-RE 提供了一种更优雅的方式，不仅借助 BTF 解耦了内核头文件的依赖，避免了运行时编译，还通过 libbpf 提供了一系列的辅助函数，方便 eBPF 程序动态探测内核所支持的特性，进而有针对性地处理。对于不支持 BTF 的内核，libbpf 还支持加载自定义的 BTF 文件，所以多内核版本的分发也不再是一个问题。对于开篇中提到的，在新内核中开发的 eBPF 程序有时没法直接在旧版本内核中运行的问题，通过这个方式也就可以解决了。


